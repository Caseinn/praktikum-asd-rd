---
title: Rekursif
description: Memahami konsep rekursi sebagai teknik pemecahan masalah dengan membagi masalah besar menjadi sub-masalah yang lebih kecil
---

Rekursif adalah teknik pemrograman dimana sebuah fungsi memanggil dirinya sendiri untuk menyelesaikan masalah yang kompleks.  
**Rekursi** adalah proses yang memecah masalah besar menjadi sub-masalah yang lebih kecil dari jenis yang sama, hingga mencapai kondisi dasar yang dapat diselesaikan langsung.  
**Divide and Conquer** adalah prinsip dasar rekursi: "pecah masalah besar menjadi masalah kecil yang sejenis".

Rekursi memberikan cara yang elegan untuk menyelesaikan masalah yang memiliki struktur berulang atau dapat didefinisikan secara rekursif.

---

## Tujuan Pembelajaran

Setelah mempelajari materi ini, mahasiswa diharapkan mampu:

- **Memahami konsep rekursi** sebagai alternatif dari pendekatan iteratif untuk menyelesaikan masalah tertentu.
- **Mengidentifikasi komponen rekursi** yaitu basis case dan recursive case dalam setiap masalah rekursif.
- **Mengimplementasikan fungsi rekursif** untuk menyelesaikan masalah matematika dan komputasi.
- **Membandingkan solusi rekursif dan iteratif** serta memahami kelebihan dan kekurangan masing-masing pendekatan.

---

## Mengapa Rekursi Penting?

1. **Pemecahan Masalah yang Natural**  
   Banyak masalah dalam matematika dan ilmu komputer secara alami bersifat rekursif. Contohnya: faktorial, fibonacci, traversal pohon, dan algoritma divide-and-conquer seperti merge sort.

2. **Kode yang Lebih Sederhana dan Elegan**  
   Untuk masalah tertentu, solusi rekursif jauh lebih pendek dan mudah dipahami dibandingkan dengan iterasi. Misalnya, faktorial dalam 5 baris vs 10 baris kode iteratif.

3. **Aplikasi dalam Struktur Data Kompleks**  
   Rekursi sangat penting untuk bekerja dengan struktur data seperti pohon (tree) dan graf, dimana struktur ini secara inherent bersifat rekursif.

4. **Fondasi Algoritma Lanjutan**  
   Banyak algoritma canggih seperti quicksort, mergesort, dan algoritma backtracking menggunakan prinsip rekursi.

---

## Komponen Rekursi

Setiap fungsi rekursif harus memiliki dua komponen utama:

### 1. Basis Case (Kondisi Berhenti)
- Kondisi dimana fungsi tidak memanggil dirinya lagi
- Memberikan jawaban langsung tanpa rekursi lebih lanjut
- Mencegah infinite loop

### 2. Recursive Case (Kondisi Rekursif)
- Fungsi memanggil dirinya sendiri dengan parameter yang "lebih kecil"
- Parameter harus menuju ke arah basis case
- Memecah masalah menjadi sub-masalah yang lebih sederhana

```cpp
// Template umum fungsi rekursif
tipe_data fungsi_rekursif(parameter) {
    if (kondisi_basis) {
        return nilai_basis;  // BASIS CASE
    } else {
        return fungsi_rekursif(parameter_baru);  // RECURSIVE CASE
    }
}
```

---

## Contoh 1: Faktorial

### Definisi Matematis
```
n! = 1             jika n = 0 (basis)
n! = n × (n-1)!    jika n > 0 (rekurens)
```

### Implementasi Rekursif
```cpp
int faktorial(int n) {
    // BASIS CASE
    if (n == 0) {
        return 1;
    } else {
        // RECURSIVE CASE  
        return n * faktorial(n - 1);
    }
}
```
```
faktorial(5)
└── 5 * faktorial(4)
    └── 4 * faktorial(3)
        └── 3 * faktorial(2)
            └── 2 * faktorial(1)
                └── 1 * faktorial(0)
                    └── 1          // Basis case tercapai
```
### Implementasi Iteratif (Perbandingan)
```cpp
int faktorialIteratif(int n) {
    int hasil = 1;
    for (int i = 1; i <= n; i++) {
        hasil *= i;
    }
    return hasil;
}
```

---

## Contoh 2: Deret Fibonacci

### Definisi Matematis
Deret Fibonacci diciptakan oleh Leonardo Fibonacci (1170-1250):
```
f(1) = 1           (basis 1)
f(2) = 1           (basis 2)  
f(n) = f(n-1) + f(n-2)  untuk n > 2 (rekurens)
```

### Deret: 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, ...

### Implementasi Fungsi
```cpp
int fibonacci(int n) {
    // BASIS CASE 1
    if (n == 1) {
        return 1;
    } 
    // BASIS CASE 2
    else if (n == 2) {
        return 1;
    } 
    // RECURSIVE CASE
    else {
        return fibonacci(n - 1) + fibonacci(n - 2);
    }
}
```

### Implementasi Prosedur
```cpp
void fibonacciProcedure(int n, int *hasil) {
    int f1, f2;
    
    if (n == 1) {
        *hasil = 1;
    } else if (n == 2) {
        *hasil = 1;
    } else {
        fibonacciProcedure(n - 1, &f1);
        fibonacciProcedure(n - 2, &f2);
        *hasil = f1 + f2;
    }
}
```

---

## Contoh Program Lengkap

```cpp
#include <iostream>
using namespace std;

// Fungsi rekursif untuk faktorial
int faktorial(int n) {
    if (n == 0) {
        return 1;
    } else {
        return n * faktorial(n - 1);
    }
}

// Fungsi rekursif untuk fibonacci
int fibonacci(int n) {
    if (n == 1 || n == 2) {
        return 1;
    } else {
        return fibonacci(n - 1) + fibonacci(n - 2);
    }
}

// Fungsi rekursif untuk penjumlahan 1+2+3+...+n
int jumlahBerurutan(int n) {
    if (n == 1) {
        return 1;
    } else {
        return n + jumlahBerurutan(n - 1);
    }
}

int main() {
    int pilihan, n;
    
    cout << "=== PROGRAM REKURSI ===" << endl;
    cout << "1. Faktorial" << endl;
    cout << "2. Fibonacci" << endl;
    cout << "3. Penjumlahan Berurutan" << endl;
    cout << "Pilih operasi: ";
    cin >> pilihan;
    
    cout << "Masukkan nilai n: ";
    cin >> n;
    
    switch(pilihan) {
        case 1:
            if (n >= 0) {
                cout << n << "! = " << faktorial(n) << endl;
            } else {
                cout << "Faktorial tidak terdefinisi untuk bilangan negatif!" << endl;
            }
            break;
            
        case 2:
            if (n > 0) {
                cout << "Fibonacci ke-" << n << " = " << fibonacci(n) << endl;
            } else {
                cout << "Input harus positif!" << endl;
            }
            break;
            
        case 3:
            if (n > 0) {
                cout << "1+2+...+" << n << " = " << jumlahBerurutan(n) << endl;
            } else {
                cout << "Tidak dapat dihitung" << endl;
            }
            break;
            
        default:
            cout << "Pilihan tidak valid!" << endl;
    }
    
    return 0;
}
```

---

## Latihan Praktik

### Latihan 1: Penjumlahan Berurutan
**Objektif**: Menghitung 1+2+3+...+n menggunakan rekursi
{/* ```cpp
// Solusi:
int jumlahBerurutan(int n) {
    if (n == 1) return 1;          // BASIS
    return n + jumlahBerurutan(n-1); // REKURENS
}
``` */}

### Latihan 2: Penjumlahan Bilangan Genap
**Objektif**: Menghitung 2+4+6+...+(2×n) menggunakan rekursi
{/* ```cpp
// Solusi:
int jumlahGenap(int n) {
    if (n == 1) return 2;          // BASIS
    return (2*n) + jumlahGenap(n-1); // REKURENS
}
``` */}

### Latihan 3: Deret Segitiga
**Objektif**: Mencari bilangan ke-n pada deret segitiga: 1, 3, 6, 10, 15, ...

{/* ```cpp
// Solusi:
int deretSegitiga(int n) {
    if (n == 1) return 1;          // BASIS
    return n + deretSegitiga(n-1); // REKURENS
}
``` */}

### Latihan 4: Cek Bilangan Ganjil
**Objektif**: Menentukan apakah bilangan ganjil tanpa operator modulus
{/* ```cpp
// Solusi:
bool isGanjil(int n) {
    if (n == 0) return false;      // BASIS
    if (n == 1) return true;       // BASIS
    return isGanjil(n - 2);        // REKURENS
}
``` */}

### Latihan 5: Luas Bujur Sangkar Rekursif
**Objektif**: Menghitung luas dengan pola: 1, 1+3, 4+5, 9+7, ...
{/* ```cpp
// Solusi:
int luasBujurSangkar(int sisi) {
    if (sisi == 1) return 1;       // BASIS
    int luasSebelum = luasBujurSangkar(sisi - 1);
    return luasSebelum + (2 * sisi - 1); // REKURENS
}
``` */}

---

## Catatan

- **Base Case**: Harus selalu terdefinisi dengan jelas dan dapat dicapai

---

*Materi - Subprogram dan Rekursif*