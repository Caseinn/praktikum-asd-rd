---
title: Queue
description: Memahami struktur data Queue dengan implementasi circular queue menggunakan array dalam pemrograman
---

**Queue** adalah struktur data linear yang mengikuti prinsip First-In-First-Out (FIFO), dimana elemen pertama yang dimasukkan akan menjadi elemen pertama yang dikeluarkan.  
**HEAD** adalah penunjuk ke elemen pertama (depan antrian) dimana penghapusan dilakukan.  
**TAIL** adalah penunjuk ke elemen terakhir (belakang antrian) dimana penyisipan dilakukan.

Queue merupakan abstraksi dari antrian dalam kehidupan nyata, seperti antrian di kasir atau antrian cetak printer.

---

## Tujuan Pembelajaran

Setelah mempelajari materi ini, mahasiswa diharapkan mampu:

- **Memahami konsep Queue** sebagai struktur data linear dengan prinsip FIFO.
- **Mengimplementasikan Queue** menggunakan array dengan berbagai alternatif representasi.
- **Menerapkan operasi Add dan Del** dengan benar sesuai definisi fungsional.
- **Memahami Circular Queue** sebagai implementasi paling efisien untuk queue dengan array.

---

## Mengapa Queue Penting?

Queue adalah struktur data fundamental yang mencerminkan antrian dalam kehidupan nyata:

1. **Job Scheduling**  
   Sistem operasi menggunakan queue untuk mengelola antrian proses yang menunggu eksekusi CPU. Proses yang datang pertama akan dieksekusi pertama (FCFS - First Come First Served).

2. **Printer Queue**  
   Dokumen yang dikirim ke printer diatur dalam queue dan dicetak sesuai urutan kedatangan. Dokumen pertama yang dikirim akan dicetak pertama.

3. **Breadth-First Search (BFS)**  
   Algoritma pencarian pada graf dan tree menggunakan queue untuk menjelajahi node secara lebar (level by level).

---

## Konsep Dasar Queue

### Definisi dan Karakteristik

Queue merupakan list linear dengan karakteristik khusus:

- **HEAD**: Elemen pertama (depan antrian) dimana penghapusan dilakukan
- **TAIL**: Elemen terakhir (belakang antrian) dimana penyisipan dilakukan
- **FIFO (First-In-First-Out)**: Elemen pertama yang masuk akan keluar pertama
- **Dua titik akses**: Penyisipan di TAIL, penghapusan di HEAD
- **Akses berurutan**: Elemen hanya bisa diakses dari HEAD

### Visualisasi Queue

```
Queue dengan operasi Add dan Del:

Del ←┌─────┬─────┬─────┬─────┐← Add
     │  2  │  7  │  3  │  5  │
     └─────┴─────┴─────┴─────┘
     HEAD              TAIL

Setelah Del():
     ┌─────┬─────┬─────┐
     │  7  │  3  │  5  │
     └─────┴─────┴─────┘
     HEAD        TAIL

Setelah Add(9):
     ┌─────┬─────┬─────┬─────┐
     │  7  │  3  │  5  │  9  │
     └─────┴─────┴─────┴─────┘
     HEAD              TAIL
```

### Prinsip FIFO

Bayangkan antrian di kasir:
- Orang pertama yang datang akan dilayani pertama
- Orang baru bergabung di belakang antrian
- Tidak bisa "menyerobot" ke depan (kecuali priority queue)

---

## Representasi Queue dengan Array

### Alternatif I: HEAD Tetap di Index 1

**Karakteristik:**
- HEAD selalu di index 1 (tidak berubah)
- TAIL bergerak saat penambahan elemen
- Memerlukan pergeseran elemen saat penghapusan
- **Tidak efisien** karena pergeseran memakan waktu O(n)

**Queue kosong:** `HEAD = 0` dan `TAIL = 0`

**Masalah:** Setiap Del() harus menggeser semua elemen ke kiri.

---

### Alternatif II: HEAD Bergerak

**Karakteristik:**
- HEAD bergerak maju saat penghapusan
- TAIL bergerak maju saat penambahan
- Tidak perlu pergeseran elemen
- **Lebih efisien**, tapi bisa terjadi "penuh semu"

**Penuh Semu:** TAIL sudah di MaxEl tetapi masih ada ruang kosong di depan.

**Solusi:** Geser semua elemen ke awal array (hanya saat TAIL = MaxEl).

---

### Alternatif III: Circular Queue (Recommended)

**Karakteristik:**
- HEAD dan TAIL "berputar" (circular/melingkar)
- Setelah index MaxEl, kembali ke index 1
- **Paling efisien**, tidak perlu pergeseran sama sekali
- Tidak ada masalah "penuh semu"

**Konsep Circular:**
```
Index berputar: 1 → 2 → 3 → 4 → 5 → 1 → 2 → ...
```

**Keuntungan:**
- Tidak ada pergeseran elemen
- Memanfaatkan ruang array secara optimal
- Operasi O(1) untuk Add dan Del

---

## Struktur Queue dan Definisi

### Definisi Struktur Queue

```cpp
#define Nil 0
#define MaxEl 5

typedef int infotype, address;
typedef struct {
    infotype T[MaxEl + 1];
    address HEAD;
    address TAIL;
} Queue;

#define Head(Q) (Q).HEAD
#define Tail(Q) (Q).TAIL
#define InfoHead(Q) (Q).T[(Q).HEAD]
#define InfoTail(Q) (Q).T[(Q).TAIL]
```

---

## Operasi Dasar Queue

### 1. Operasi CreateEmpty

```cpp
void CreateEmpty(Queue *Q) {
    Head(*Q) = Tail(*Q) = Nil;
}
```

Fungsi ini menginisialisasi queue kosong dengan mengatur HEAD dan TAIL ke Nil (0).

### 2. Operasi IsEmpty

```cpp
bool isEmpty(Queue Q) {
    return ((Head(Q) == Nil) && (Tail(Q) == Nil));
}
```

Mengembalikan `true` jika HEAD dan TAIL keduanya bernilai Nil, artinya queue kosong.


### 3. Fungsi NbElmt

```cpp
int NbElmt(Queue Q) {
    if (isEmpty(Q)) {
        return 0;
    } else {
        if (Head(Q) <= Tail(Q)) {
            return (Tail(Q) - Head(Q) + 1);
        } else {
            return (MaxEl - Head(Q) + Tail(Q) + 1);
        }
    }
}
```

**Penjelasan Perhitungan:**

**Kasus Normal (HEAD ≤ TAIL):**
```
┌─────┬─────┬─────┬─────┬─────┐
│     │  3  │  7  │  9  │     │
└─────┴─────┴─────┴─────┴─────┘
        HEAD        TAIL
         2           4

Jumlah = TAIL - HEAD + 1 = 4 - 2 + 1 = 3 elemen
```

**Kasus Circular (HEAD > TAIL):**
```
┌─────┬─────┬─────┬─────┬─────┐
│  9  │ 11  │     │     │  5  │
└─────┴─────┴─────┴─────┴─────┘
        TAIL              HEAD
         2                 5

Jumlah = (MaxEl - HEAD + 1) + TAIL = 3 elemen
```


### 4. Operasi IsFull

```cpp
bool isFull(Queue Q) {
    return (NbElmt(Q) == MaxEl);
}
```

Mengembalikan `true` jika jumlah elemen sama dengan kapasitas maksimum.


### 5. Operasi Add

```cpp
void Add(Queue *Q, infotype x) {
    if (!isFull(*Q)) {
        if (isEmpty(*Q)) {
            Head(*Q) = Tail(*Q) = 1;
        } else {
            if (Tail(*Q) == MaxEl) {
                Tail(*Q) = 1;
            } else {
                Tail(*Q)++;
            }
        }
        InfoTail(*Q) = x;
    } else {
        cout << "Queue Penuh" << endl;
    }
}
```

**Langkah Add:**
1. Cek apakah queue penuh
2. Jika kosong: set HEAD dan TAIL ke 1
3. Jika tidak kosong: majukan TAIL (circular jika perlu)
4. Simpan nilai x di TAIL
5. Jika penuh: tampilkan pesan error


### 6. Operasi Del

```cpp
void Del(Queue *Q, infotype *x) {
    if (!isEmpty(*Q)) {
        *x = InfoHead(*Q);
        if (Head(*Q) == Tail(*Q)) {
            Head(*Q) = Tail(*Q) = Nil;
        } else {
            if (Head(*Q) == MaxEl) {
                Head(*Q) = 1;
            } else {
                Head(*Q)++;
            }
        }
    } else {
        cout << "Queue Kosong" << endl;
    }
}
```

**Langkah Del:**
1. Cek apakah queue kosong
2. Jika tidak kosong: ambil nilai HEAD
3. Jika hanya 1 elemen: set HEAD dan TAIL ke Nil
4. Jika lebih dari 1: majukan HEAD (circular jika perlu)
5. Jika kosong: tampilkan pesan error

---

## Contoh Program Lengkap

```cpp
#include <iostream>
using namespace std;

#define Nil 0
#define MaxEl 5

typedef int infotype, address;
typedef struct {
    infotype T[MaxEl + 1];
    address HEAD;
    address TAIL;
} Queue;

#define Head(Q) (Q).HEAD
#define Tail(Q) (Q).TAIL
#define InfoHead(Q) (Q).T[(Q).HEAD]
#define InfoTail(Q) (Q).T[(Q).TAIL]

void CreateEmpty(Queue *Q) {
    Head(*Q) = Tail(*Q) = Nil;
}

bool isEmpty(Queue Q) {
    return ((Head(Q) == Nil) && (Tail(Q) == Nil));
}

int NbElmt(Queue Q) {
    if (isEmpty(Q)) {
        return 0;
    } else {
        if (Head(Q) <= Tail(Q)) {
            return (Tail(Q) - Head(Q) + 1);
        } else {
            return (MaxEl - Head(Q) + Tail(Q) + 1);
        }
    }
}

bool isFull(Queue Q) {
    return (NbElmt(Q) == MaxEl);
}

void Add(Queue *Q, infotype x) {
    if (!isFull(*Q)) {
        if (isEmpty(*Q)) {
            Head(*Q) = Tail(*Q) = 1;
        } else {
            if (Tail(*Q) == MaxEl) {
                Tail(*Q) = 1;
            } else {
                Tail(*Q)++;
            }
        }
        InfoTail(*Q) = x;
    } else {
        cout << "Queue Penuh" << endl;
    }
}

void Del(Queue *Q, infotype *x) {
    if (!isEmpty(*Q)) {
        *x = InfoHead(*Q);
        if (Head(*Q) == Tail(*Q)) {
            Head(*Q) = Tail(*Q) = Nil;
        } else {
            if (Head(*Q) == MaxEl) {
                Head(*Q) = 1;
            } else {
                Head(*Q)++;
            }
        }
    } else {
        cout << "Queue Kosong" << endl;
    }
}

int main() {
    Queue DataTest;
    infotype DataHapus;
    
    // Inisialisasi queue kosong
    CreateEmpty(&DataTest);
    
    // Menambahkan elemen
    cout << "Add(3)" << endl;
    Add(&DataTest, 3);
    
    cout << "Add(7)" << endl;
    Add(&DataTest, 7);
    
    cout << "Add(5)" << endl;
    Add(&DataTest, 5);
    
    cout << "Add(9)" << endl;
    Add(&DataTest, 9);
    
    // Menghapus satu elemen
    Del(&DataTest, &DataHapus);
    cout << "\nDel(" << DataHapus << ")" << endl;
    
    // Menampilkan semua isi queue
    cout << "\nIsi Queue (FIFO):" << endl;
    while (!isEmpty(DataTest)) {
        Del(&DataTest, &DataHapus);
        cout << DataHapus << endl;
    }
    
    return 0;
}
```

**Output Program:**
```
Add(3)
Add(7)
Add(5)
Add(9)

Del(3)

Isi Queue (FIFO):
7
5
9
```

---

## Latihan

### Latihan 1: Simulasi Antrian Bank
**Objektif**: Menggunakan queue untuk simulasi antrian pelayanan bank.

**Spesifikasi:**
- Input: Nomor antrian pelanggan (contoh: 101, 102, 103)
- Proses: Add pelanggan ke queue, Del untuk melayani
- Output: Urutan pelayanan sesuai FIFO

---

## Implementasi Queue dengan List

Selain array, Queue dapat diimplementasikan menggunakan linked list:

### Karakteristik Queue dengan List

- **Add**: Gunakan operasi `InsertLast` (tambah di akhir list)
- **Del**: Gunakan operasi `DeleteFirst` (hapus dari depan list)
- **HEAD**: Selalu elemen pertama dalam linked list
- **TAIL**: Selalu elemen terakhir dalam linked list

---

*Materi - Stack Dan Queue dengan Array*  

---