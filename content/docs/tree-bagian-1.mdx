---
title: Tree - Bagian 1
description: Memahami struktur data Tree dan Binary Tree dengan implementasi menggunakan linked list dalam pemrograman
---

**Tree (Pohon)** adalah struktur data hierarkis yang terdiri dari simpul-simpul (nodes) yang saling terhubung. Setiap pohon memiliki sebuah **akar (root)** dan dapat memiliki beberapa **subpohon (subtree)** yang merupakan pohon itu sendiri.  
**Binary Tree (Pohon Biner)** adalah jenis pohon khusus dimana setiap simpul maksimal memiliki dua anak: subpohon kiri (left subtree) dan subpohon kanan (right subtree).

Tree merupakan representasi dari struktur hierarkis dalam kehidupan sehari-hari, seperti struktur organisasi, sistem file komputer, atau pohon keluarga.

---

## Tujuan Pembelajaran

Setelah mempelajari materi ini, mahasiswa diharapkan mampu:

- **Memahami konsep Tree** sebagai struktur data hierarkis dan definisi rekursifnya.
- **Memahami Binary Tree** dan perbedaannya dengan tree umum.
- **Mengimplementasikan Binary Tree** menggunakan linked list dengan pointer left dan right.
- **Menerapkan operasi traversal** (PreOrder, InOrder, PostOrder) untuk memproses semua node dalam tree.
- **Membuat fungsi rekursif** untuk memanipulasi dan menganalisis struktur tree.

---

## Mengapa Tree Penting?

Tree adalah struktur data fundamental yang digunakan dalam berbagai aplikasi komputer:

1. **Sistem File**  
   Sistem operasi menggunakan tree untuk mengorganisir direktori dan file. Setiap folder dapat berisi subfolder dan file, membentuk struktur hierarkis.

2. **Database dan Indexing**  
   Binary Search Tree (BST) dan B-Tree digunakan dalam database untuk indexing dan pencarian data yang efisien.

3. **Compiler dan Expression Parsing**  
   Compiler menggunakan tree (Abstract Syntax Tree) untuk merepresentasikan dan mengevaluasi ekspresi matematika atau kode program.

4. **Artificial Intelligence**  
   Decision tree digunakan dalam machine learning dan AI untuk membuat keputusan berdasarkan kondisi-kondisi tertentu.

---

## Konsep Dasar Tree

### Definisi Rekursif Tree

Tree didefinisikan secara rekursif sebagai berikut:

- **Basis**: Sebuah simpul tunggal yang disebut **AKAR (root)** adalah tree
- **Rekurens**: Elemen lain (jika ada) dibagi menjadi beberapa subhimpunan yang disjoint, dan masing-masing subhimpunan adalah tree yang disebut **SUBPOHON (subtree)**

### Definisi Binary Tree

Binary Tree adalah himpunan terbatas yang:
- Terdiri atas sebuah simpul yang disebut **akar (root)**
- Memiliki dua buah himpunan lain yang disjoint yang merupakan pohon biner: **subpohon kiri (left subtree)** dan **subpohon kanan (right subtree)**

### Visualisasi Binary Tree

```
Binary Tree Normal:
         a
        / \
       b   c
      /   / \
     d   g   h
              \
               i

Binary Tree Skewed (Condong):
    
Condong Kiri:          Condong Kanan:
      a                      a
     /                        \
    b                          b
   /                            \
  c                              c

Expression Tree (3 + (4 * 5)):
         +
        / \
       3   *
          / \
         4   5
```

### Terminologi Penting

- **Root (Akar)**: Simpul paling atas tanpa parent
- **Parent (Orang Tua)**: Simpul yang memiliki anak
- **Child (Anak)**: Simpul yang memiliki parent
- **Sibling (Saudara)**: Simpul-simpul dengan parent yang sama
- **Leaf (Daun)**: Simpul terminal tanpa anak
- **Path (Jalan)**: Urutan simpul dari satu simpul ke simpul lain
- **Degree (Derajat)**: Banyaknya anak sebuah simpul
- **Level (Tingkat)**: Panjang path dari root ke simpul tertentu (root = level 1)
- **Depth/Height (Kedalaman/Tinggi)**: Level maksimum dalam tree

### Contoh Terminologi

```
         a          ← Root (level 1)
        / \
       b   c        ← Level 2
      / \   \
     d   e   f      ← Level 3 (d, e, f adalah Leaf)

- Parent(d) = b
- Child(a) = {b, c}
- Sibling(d) = e
- Degree(b) = 2
- Degree(d) = 0
- Level(d) = 3
- Height pohon = 3
```

---

## Struktur Binary Tree dan Definisi

### Definisi Struktur Binary Tree

```cpp
typedef int infotype;
typedef struct tNode *addrNode;
typedef addrNode BinTree;

typedef struct tNode {
    infotype info;
    addrNode left;
    addrNode right;
} Node;

/* Selektor */
#define Akar(P) (P)->info
#define Left(P) (P)->left
#define Right(P) (P)->right
#define Nil NULL
```

**Penjelasan:**
- `BinTree` adalah pointer ke root node
- Setiap node memiliki `info` (data), `left` (pointer ke anak kiri), dan `right` (pointer ke anak kanan)
- `Nil` merepresentasikan tree kosong atau pointer kosong

---

## Operasi Dasar Binary Tree

### 1. Operasi CreateEmpty

```cpp
void CreateEmpty(BinTree *P) {
    *P = Nil;
}
```

Fungsi ini menginisialisasi binary tree kosong dengan mengatur pointer root ke Nil.

### 2. Operasi AlokNode

```cpp
addrNode AlokNode(infotype X) {
    addrNode P = (addrNode)malloc(sizeof(Node));
    if (P != Nil) {
        Akar(P) = X;
        Left(P) = Nil;
        Right(P) = Nil;
    }
    return P;
}
```

Mengalokasikan memori untuk node baru dengan nilai X, dan menginisialisasi left dan right ke Nil.

### 3. Operasi DealokNode

```cpp
void DealokNode(addrNode P) {
    free(P);
}
```

Mengembalikan memori node P ke sistem.

### 4. Operasi Tree (Konstruktor)

```cpp
BinTree Tree(infotype A, BinTree L, BinTree R) {
    BinTree T = AlokNode(A);
    if (T != Nil) {
        Left(T) = L;
        Right(T) = R;
    }
    return T;
}
```

Membuat binary tree baru dengan akar A, subpohon kiri L, dan subpohon kanan R.

**Contoh Penggunaan:**
```cpp
// Membuat tree:    1
//                 / \
//                2   3

BinTree leaf2 = Tree(2, Nil, Nil);
BinTree leaf3 = Tree(3, Nil, Nil);
BinTree root = Tree(1, leaf2, leaf3);
```

---

## Predikat Binary Tree

### 1. IsTreeEmpty

```cpp
bool IsTreeEmpty(BinTree P) {
    return (P == Nil);
}
```

Mengembalikan `true` jika tree kosong.

### 2. IsTreeOneElmt

```cpp
bool IsTreeOneElmt(BinTree P) {
    if (P != Nil)
        return (Left(P) == Nil && Right(P) == Nil);
    else
        return false;
}
```

Mengembalikan `true` jika tree hanya memiliki 1 elemen (hanya root tanpa anak).

### 3. IsUnerLeft

```cpp
bool IsUnerLeft(BinTree P) {
    if (P != Nil)
        return (Left(P) != Nil && Right(P) == Nil);
    else
        return false;
}
```

Mengembalikan `true` jika tree hanya memiliki subpohon kiri (unary left).

### 4. IsUnerRight

```cpp
bool IsUnerRight(BinTree P) {
    if (P != Nil)
        return (Left(P) == Nil && Right(P) != Nil);
    else
        return false;
}
```

Mengembalikan `true` jika tree hanya memiliki subpohon kanan (unary right).

### 5. IsBiner

```cpp
bool IsBiner(BinTree P) {
    if (P != Nil)
        return (Left(P) != Nil && Right(P) != Nil);
    else
        return false;
}
```

Mengembalikan `true` jika tree memiliki kedua subpohon (kiri dan kanan).

---

## Traversal Binary Tree

Traversal adalah proses mengunjungi setiap node dalam tree tepat satu kali dengan urutan tertentu.

### 1. PreOrder Traversal (Root-Left-Right)

```cpp
void PreOrder(BinTree P) {
    if (IsTreeEmpty(P)) {
        // Basis-0: do nothing
    } else {
        // Rekurens
        cout << Akar(P) << " ";  // Proses root
        PreOrder(Left(P));        // Proses left
        PreOrder(Right(P));       // Proses right
    }
}
```

**Urutan:** Root → Left → Right

**Contoh:**
```
Tree:     1
         / \
        2   3
       / \
      4   5

PreOrder: 1 2 4 5 3
```

### 2. InOrder Traversal (Left-Root-Right)

```cpp
void InOrder(BinTree P) {
    if (IsTreeEmpty(P)) {
        // Basis-0: do nothing
    } else {
        // Rekurens
        InOrder(Left(P));         // Proses left
        cout << Akar(P) << " ";   // Proses root
        InOrder(Right(P));        // Proses right
    }
}
```

**Urutan:** Left → Root → Right

**Contoh:**
```
Tree:     1
         / \
        2   3
       / \
      4   5

InOrder: 4 2 5 1 3
```

### 3. PostOrder Traversal (Left-Right-Root)

```cpp
void PostOrder(BinTree P) {
    if (IsTreeEmpty(P)) {
        // Basis-0: do nothing
    } else {
        // Rekurens
        PostOrder(Left(P));       // Proses left
        PostOrder(Right(P));      // Proses right
        cout << Akar(P) << " ";   // Proses root
    }
}
```

**Urutan:** Left → Right → Root

**Contoh:**
```
Tree:     1
         / \
        2   3
       / \
      4   5

PostOrder: 4 5 2 3 1
```

---

## Operasi Rekursif pada Binary Tree

### 1. Menghitung Jumlah Elemen

```cpp
int NbElmt(BinTree P) {
    if (IsTreeEmpty(P)) {
        // Basis-0
        return 0;
    } else {
        // Rekurens
        return (1 + NbElmt(Left(P)) + NbElmt(Right(P)));
    }
}
```

**Logika:** Jumlah elemen = 1 (root) + jumlah elemen kiri + jumlah elemen kanan

### 2. Menghitung Jumlah Daun

```cpp
int NbDaun(BinTree P) {
    if (IsTreeOneElmt(P)) {
        // Basis-1: satu elemen adalah daun
        return 1;
    } else {
        // Rekurens
        if (IsUnerLeft(P))
            return NbDaun(Left(P));
        else if (IsUnerRight(P))
            return NbDaun(Right(P));
        else // IsBiner(P)
            return (NbDaun(Left(P)) + NbDaun(Right(P)));
    }
}
```

**Logika:** Node adalah daun jika tidak memiliki anak. Hitung semua daun di subpohon kiri dan kanan.

### 3. Menghitung Tinggi/Kedalaman Tree

```cpp
int Tinggi(BinTree P) {
    if (IsTreeEmpty(P)) {
        // Basis-0: tinggi tree kosong = 0
        return 0;
    } else {
        // Rekurens
        int tLeft = Tinggi(Left(P));
        int tRight = Tinggi(Right(P));
        
        if (tLeft > tRight)
            return (1 + tLeft);
        else
            return (1 + tRight);
    }
}
```

**Logika:** Tinggi tree = 1 + maksimum(tinggi subpohon kiri, tinggi subpohon kanan)

### 4. Menghapus Daun Terkiri

```cpp
void DelDaunTerkiri(BinTree *P, infotype *X) {
    addrNode PDel;
    
    if (IsTreeOneElmt(*P)) {
        // Basis-1: hanya ada root
        *X = Akar(*P);
        PDel = *P;
        *P = Nil;
        DealokNode(PDel);
    } else {
        // Rekurens
        if (IsUnerRight(*P))
            DelDaunTerkiri(&Right(*P), X);
        else // IsUnerLeft atau IsBiner
            DelDaunTerkiri(&Left(*P), X);
    }
}
```

**Logika:** Telusuri terus ke kiri sampai menemukan daun paling kiri, lalu hapus.

---

## Contoh Program Lengkap

```cpp
#include <iostream>
using namespace std;

typedef int infotype;
typedef struct tNode *addrNode;
typedef addrNode BinTree;

typedef struct tNode {
    infotype info;
    addrNode left;
    addrNode right;
} Node;

#define Akar(P) (P)->info
#define Left(P) (P)->left
#define Right(P) (P)->right
#define Nil NULL

// Alokasi dan Dealokasi
addrNode AlokNode(infotype X) {
    addrNode P = (addrNode)malloc(sizeof(Node));
    if (P != Nil) {
        Akar(P) = X;
        Left(P) = Nil;
        Right(P) = Nil;
    }
    return P;
}

void DealokNode(addrNode P) {
    free(P);
}

// Konstruktor
BinTree Tree(infotype A, BinTree L, BinTree R) {
    BinTree T = AlokNode(A);
    if (T != Nil) {
        Left(T) = L;
        Right(T) = R;
    }
    return T;
}

// Predikat
bool IsTreeEmpty(BinTree P) {
    return (P == Nil);
}

// Traversal
void PreOrder(BinTree P) {
    if (!IsTreeEmpty(P)) {
        cout << Akar(P) << " ";
        PreOrder(Left(P));
        PreOrder(Right(P));
    }
}

void InOrder(BinTree P) {
    if (!IsTreeEmpty(P)) {
        InOrder(Left(P));
        cout << Akar(P) << " ";
        InOrder(Right(P));
    }
}

void PostOrder(BinTree P) {
    if (!IsTreeEmpty(P)) {
        PostOrder(Left(P));
        PostOrder(Right(P));
        cout << Akar(P) << " ";
    }
}

// Operasi Rekursif
int NbElmt(BinTree P) {
    if (IsTreeEmpty(P))
        return 0;
    else
        return (1 + NbElmt(Left(P)) + NbElmt(Right(P)));
}

int Tinggi(BinTree P) {
    if (IsTreeEmpty(P))
        return 0;
    else {
        int tLeft = Tinggi(Left(P));
        int tRight = Tinggi(Right(P));
        return (1 + (tLeft > tRight ? tLeft : tRight));
    }
}

int main() {
    // Membuat tree:
    //       1
    //      / \
    //     2   3
    //    / \
    //   4   5
    
    BinTree leaf4 = Tree(4, Nil, Nil);
    BinTree leaf5 = Tree(5, Nil, Nil);
    BinTree leaf3 = Tree(3, Nil, Nil);
    BinTree node2 = Tree(2, leaf4, leaf5);
    BinTree root = Tree(1, node2, leaf3);
    
    cout << "PreOrder: ";
    PreOrder(root);
    cout << endl;
    
    cout << "InOrder: ";
    InOrder(root);
    cout << endl;
    
    cout << "PostOrder: ";
    PostOrder(root);
    cout << endl;
    
    cout << "\nJumlah Elemen: " << NbElmt(root) << endl;
    cout << "Tinggi Tree: " << Tinggi(root) << endl;
    
    return 0;
}
```

**Output Program:**
```
PreOrder: 1 2 4 5 3
InOrder: 4 2 5 1 3
PostOrder: 4 5 2 3 1

Jumlah Elemen: 5
Tinggi Tree: 3
```

---

### Latihan 1: Menghitung Node dengan Dua Anak
**Objektif**: Menghitung jumlah node yang memiliki tepat dua anak.

**Spesifikasi:**
- Input: Binary tree
- Proses: Hitung semua node yang IsBiner (memiliki left dan right)
- Output: Jumlah node dengan dua anak

{/*
int NbNodeBiner(BinTree P) {
    if (IsTreeEmpty(P)) {
        return 0;
    }

    int self = 0;
    if (Left(P) != Nil && Right(P) != Nil) {
        self = 1;
    }

    return self + NbNodeBiner(Left(P)) + NbNodeBiner(Right(P));
}
*/}

---

### Latihan 2: Mirror Binary Tree
**Objektif**: Membuat mirror (cerminan) dari binary tree.

**Spesifikasi:**
- Input: Binary tree
- Proses: Tukar semua subpohon kiri dan kanan secara rekursif
- Output: Binary tree yang merupakan mirror dari input

**Contoh:**
```
Input:       1          Output:      1
            / \                     / \
           2   3                   3   2
          / \                         / \
         4   5                       5   4
```

{/*
void Mirror(BinTree *P) {
    if (IsTreeEmpty(*P)) return;
    BinTree tmp = Left(*P);
    Left(*P) = Right(*P);
    Right(*P) = tmp;

    // lanjutkan ke bawah
    Mirror(&Left(*P));
    Mirror(&Right(*P));
}
*/}

---

## Tips Implementasi Binary Tree

1. **Selalu cek kondisi kosong** sebelum mengakses node
2. **Gunakan basis rekursif yang tepat**: Basis-0 (tree kosong) atau Basis-1 (satu elemen)
3. **Pahami urutan traversal**: PreOrder untuk copy, InOrder untuk sorted data, PostOrder untuk delete
4. **Dealokasi memori** dengan benar menggunakan PostOrder traversal
5. **Visualisasikan tree** di kertas untuk memahami logika rekursif

---

*Materi - Tree Bagian 1*

---