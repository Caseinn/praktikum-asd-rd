---
title: Tree - Bagian 2
description: Memahami operasi-operasi lanjutan pada Binary Tree termasuk pencarian, manipulasi, dan konversi ke struktur data lain
---

**Tree Bagian 2** membahas operasi-operasi lanjutan pada Binary Tree yang lebih kompleks, termasuk pencarian node dan daun, identifikasi pola tree, manipulasi struktur tree, dan konversi tree ke struktur data list.

Materi ini merupakan lanjutan dari Tree Bagian 1 dan memerlukan pemahaman yang baik tentang konsep rekursif dan operasi dasar Binary Tree.

---

## Tujuan Pembelajaran

Setelah mempelajari materi ini, mahasiswa diharapkan mampu:

- **Mengimplementasikan fungsi pencarian** untuk mencari node atau daun dengan nilai tertentu dalam tree.
- **Mengidentifikasi pola tree** seperti skewed tree (condong kiri/kanan).
- **Menghitung level node** dalam Binary Tree.
- **Memanipulasi struktur tree** dengan menambah atau menghapus daun.
- **Mengkonversi tree ke list** untuk keperluan pemrosesan data tertentu.

---

## Operasi Pencarian pada Binary Tree

### 1. SearchTree - Mencari Node

```cpp
bool SearchTree(BinTree P, infotype X) {
    /* Mengirimkan true jika ada node dari P yang bernilai X */
    
    if (IsTreeEmpty(P)) {
        // Basis-0: tree kosong
        return false;
    } else {
        // Rekurens
        if (Akar(P) == X)
            return true;
        else
            return (SearchTree(Left(P), X) || SearchTree(Right(P), X));
    }
}
```

**Logika:**
- Basis: Jika tree kosong, nilai tidak ditemukan
- Rekurens: Cek akar, jika cocok return true; jika tidak, cari di subpohon kiri OR kanan
- Menggunakan operator OR (||) karena cukup ditemukan di salah satu subpohon

**Visualisasi:**
```
Tree:       5
           / \
          3   8
         / \
        1   4

SearchTree(P, 4):
- Cek akar (5) ≠ 4
- Cari di left (3):
  - Cek akar (3) ≠ 4
  - Cari di left (1): false
  - Cari di right (4): TRUE ✓
- Return: true
```

### 2. SearchDaun - Mencari Daun

```cpp
bool SearchDaun(BinTree P, infotype X) {
    /* Mengirimkan true jika ada daun dari P yang bernilai X */
    /* Prekondisi: P tidak kosong */
    
    if (IsTreeOneElmt(P)) {
        // Basis-1: satu elemen adalah daun
        return (Akar(P) == X);
    } else {
        // Rekurens
        if (IsUnerLeft(P))
            return SearchDaun(Left(P), X);
        else if (IsUnerRight(P))
            return SearchDaun(Right(P), X);
        else // IsBiner(P)
            return (SearchDaun(Left(P), X) || SearchDaun(Right(P), X));
    }
}
```

**Perbedaan dengan SearchTree:**
- Hanya mencari di node yang merupakan daun (tanpa anak)
- Tidak perlu cek akar di rekurens karena jika ada anak, akar bukan daun

**Contoh:**
```
Tree:       5
           / \
          3   8
         / \
        1   4

SearchDaun(P, 5): false (5 bukan daun)
SearchDaun(P, 1): true (1 adalah daun)
SearchDaun(P, 4): true (4 adalah daun)
```

---

## Identifikasi Pola Tree

### 1. IsSkewLeft - Pohon Condong Kiri

```cpp
bool IsSkewLeft(BinTree P) {
    /* Mengirimkan true jika P adalah pohon condong kiri */
    /* Pohon kosong adalah pohon condong kiri */
    
    if (IsTreeEmpty(P)) {
        // Basis-0: pohon kosong dianggap condong kiri
        return true;
    } else if (IsTreeOneElmt(P)) {
        // Basis-1: satu elemen adalah condong kiri
        return true;
    } else {
        // Rekurens
        if (IsUnerLeft(P))
            return IsSkewLeft(Left(P));
        else
            return false;
    }
}
```

**Karakteristik Pohon Condong Kiri:**
- Setiap node hanya memiliki anak kiri
- Tidak ada node dengan anak kanan
- Membentuk struktur linear ke kiri

**Visualisasi:**
```
Condong Kiri:      Bukan Condong Kiri:
      a                  a
     /                  / \
    b                  b   c
   /                  /
  c                  d
```

### 2. IsSkewRight - Pohon Condong Kanan

```cpp
bool IsSkewRight(BinTree P) {
    /* Mengirimkan true jika P adalah pohon condong kanan */
    /* Pohon kosong adalah pohon condong kanan */
    
    if (IsTreeEmpty(P)) {
        // Basis-0: pohon kosong dianggap condong kanan
        return true;
    } else if (IsTreeOneElmt(P)) {
        // Basis-1: satu elemen adalah condong kanan
        return true;
    } else {
        // Rekurens
        if (IsUnerRight(P))
            return IsSkewRight(Right(P));
        else
            return false;
    }
}
```

**Karakteristik Pohon Condong Kanan:**
- Setiap node hanya memiliki anak kanan
- Tidak ada node dengan anak kiri
- Membentuk struktur linear ke kanan

---

## Operasi Level pada Tree

### Level - Menghitung Level Node

```cpp
infotype Level(BinTree P, infotype X) {
    /* Mengirimkan level dari node X yang merupakan salah satu simpul
       dari pohon biner P. Akar(P) level-nya adalah 1. 
       Prekondisi: Pohon P tidak kosong dan X pasti ada di P */
    
    if (Akar(P) == X) {
        // Basis-1: ketemu di akar
        return 1;
    } else {
        // Rekurens
        if (SearchTree(Left(P), X))
            return (1 + Level(Left(P), X));
        else // Pasti di pohon kanan
            return (1 + Level(Right(P), X));
    }
}
```

**Logika:**
- Level akar = 1
- Level node = 1 + Level(parent)
- Gunakan SearchTree untuk menentukan apakah X ada di subpohon kiri atau kanan

**Contoh:**
```
Tree:       5  (level 1)
           / \
          3   8  (level 2)
         / \
        1   4  (level 3)

Level(P, 5) = 1
Level(P, 3) = 2
Level(P, 1) = 3
Level(P, 4) = 3
```

---

## Manipulasi Struktur Tree

### 1. AddDaun - Menambah Daun

```cpp
void AddDaun(BinTree *P, infotype X, infotype Y, bool Kiri) {
    /* I.S. P tidak kosong, X adalah salah satu daun Pohon Biner P */
    /* F.S. P bertambah simpulnya, dengan Y sebagai anak kiri X 
           (jika Kiri = true) atau sebagai anak kanan X (jika Kiri = false) */
    /* Jika ada > 1 daun bernilai X, diambil daun yang paling kiri */
    
    addrNode PNew;
    
    if (IsTreeOneElmt(*P) || Akar(*P) == X) {
        // Basis-1: Akar(P) pasti = X (karena X adalah daun)
        PNew = Tree(Y, Nil, Nil);
        
        if (Kiri) {
            if (Left(*P) == Nil)
                Left(*P) = PNew;
            else
                cout << "Gagal Tambah Daun" << endl;
        } else { // not Kiri
            if (Right(*P) == Nil)
                Right(*P) = PNew;
            else
                cout << "Gagal Tambah Daun" << endl;
        }
    } else {
        // Rekurens
        if (SearchTree(Left(*P), X))
            AddDaun(&(Left(*P)), X, Y, Kiri);
        else // Pasti X di pohon kanan
            AddDaun(&(Right(*P)), X, Y, Kiri);
    }
}
```

**Langkah-langkah:**
1. Cari daun dengan nilai X
2. Alokasi node baru dengan nilai Y
3. Tambahkan sebagai anak kiri atau kanan dari X
4. Jika ada lebih dari satu daun bernilai X, pilih yang paling kiri

**Contoh Penggunaan:**
```cpp
// Tree awal:    5
//              / \
//             3   8

AddDaun(&P, 3, 1, true);  // Tambah 1 sebagai anak kiri 3

// Tree hasil:   5
//              / \
//             3   8
//            /
//           1
```

### 2. DelDaun - Menghapus Daun (Versi 1)

```cpp
void DelDaun(BinTree *P, infotype X) {
    /* I.S. P tidak kosong, minimum ada 1 daun bernilai X */
    /* F.S. Semua daun bernilai X dihapus dari P */
    
    addrNode PDel;
    
    if (IsTreeOneElmt(*P)) {
        // Basis-1: Akar(P) belum tentu X
        if (Akar(*P) == X) {
            PDel = *P;
            *P = Nil;
            DealokNode(PDel);
        } // do nothing kalau Akar(P) bukan X
    } else {
        // Rekurens
        if (SearchTree(Left(*P), X))  // X belum tentu di daun
            DelDaun(&(Left(*P)), X);
        if (SearchTree(Right(*P), X)) // X belum tentu di daun
            DelDaun(&(Right(*P)), X);
    }
}
```

**Karakteristik Versi 1:**
- Menggunakan SearchTree untuk mencari X
- Lebih umum karena cek semua kemungkinan
- Menghapus SEMUA daun bernilai X

### 3. DelDaun - Menghapus Daun (Versi 2)

```cpp
void DelDaun(BinTree *P, infotype X) {
    /* I.S. P tidak kosong, minimum ada 1 daun bernilai X */
    /* F.S. Semua daun bernilai X dihapus dari P */
    
    addrNode PDel;
    
    if (IsTreeOneElmt(*P)) {
        // Basis-1: Akar(P) pasti X (karena sudah dicek dengan SearchDaun)
        PDel = *P;
        *P = Nil;
        DealokNode(PDel);
    } else {
        // Rekurens
        if (IsUnerLeft(*P))
            DelDaun(&(Left(*P)), X);
        else if (IsUnerRight(*P))
            DelDaun(&(Right(*P)), X);
        else { // IsBiner(P)
            if (SearchDaun(Left(*P), X))
                DelDaun(&(Left(*P)), X);
            if (SearchDaun(Right(*P), X))
                DelDaun(&(Right(*P)), X);
        }
    }
}
```

**Perbedaan Versi 1 dan Versi 2:**

| Aspek | Versi 1 (SearchTree) | Versi 2 (SearchDaun) |
|-------|---------------------|---------------------|
| **Fungsi Cek** | SearchTree | SearchDaun |
| **Efisiensi** | Cek semua node | Hanya cek daun |
| **Kompleksitas** | Lebih sederhana | Lebih kompleks (perlu predikat) |
| **Kecepatan** | Lebih lambat | Lebih cepat |

---

## Konversi Tree ke List

### 1. Fungsi Concat (Helper)

```cpp
List Concat(List L1, List L2) {
    /* Mengirimkan salinan hasil konkatenasi list L1 dan L2 */
    /* Jika ada alokasi gagal, menghasilkan Nil */
    
    List LTemp;
    
    if (IsEmpty(L1)) {
        // Basis-0
        return Copy(L2);
    } else {
        // Rekurens
        LTemp = Concat(Next(L1), L2);
        InsVFirst(&LTemp, Info(L1));
        return LTemp;
    }
}
```

**Fungsi:** Menggabungkan dua list menjadi satu list baru.

### 2. MakeListDaun - Membuat List dari Daun

```cpp
List MakeListDaun(BinTree P) {
    /* Jika P adalah pohon kosong, maka menghasilkan list kosong */
    /* Jika P bukan pohon kosong: menghasilkan list yang elemennya 
       adalah semua daun pohon P, jika semua alokasi list berhasil */
    /* Daun terkiri menjadi elemen pertama dari list */
    
    if (IsTreeEmpty(P)) {
        // Basis-0
        return Nil;
    } else {
        // Rekurens
        return MakeListDaunRecc(P);
    }
}

List MakeListDaunRecc(BinTree P) {
    /* P bukan pohon kosong */
    /* Menghasilkan list yang elemennya adalah semua daun pohon P */
    
    List ll, lr;
    
    if (IsTreeOneElmt(P)) {
        // Basis-1: satu elemen adalah daun
        return Konso(Akar(P), Nil);
    } else {
        // Rekurens
        if (IsUnerLeft(P))
            return MakeListDaunRecc(Left(P));
        else if (IsUnerRight(P))
            return MakeListDaunRecc(Right(P));
        else { // IsBiner(P)
            ll = MakeListDaunRecc(Left(P));
            lr = MakeListDaunRecc(Right(P));
            
            if (ll != Nil && lr != Nil)
                return Concat(ll, lr);
            else
                return Nil;
        }
    }
}
```

**Logika:**
- Traversal tree untuk mencari semua daun
- Daun kiri dikumpulkan terlebih dahulu
- Gabungkan list daun kiri dan daun kanan
- Urutan: daun terkiri → daun terkanan

**Contoh:**
```
Tree:       5
           / \
          3   8
         / \
        1   4

MakeListDaun(P) → [1, 4, 8]
```

### 3. MakeListLevel - Membuat List dari Level Tertentu

```cpp
List MakeListLevel(BinTree P, int N) {
    /* Jika P adalah pohon kosong, maka menghasilkan list kosong */
    /* Jika P bukan pohon kosong: menghasilkan list yang elemennya 
       adalah semua elemen pohon P yang levelnya = N */
    /* Elemen terkiri menjadi elemen pertama dari list */
    
    if (IsTreeEmpty(P)) {
        // Basis-0
        return Nil;
    } else {
        // Rekurens
        return MakeListLevelRecc(P, N);
    }
}

List MakeListLevelRecc(BinTree P, int N) {
    /* P bukan pohon kosong */
    /* Menghasilkan list yang elemennya adalah semua elemen pohon P 
       yang levelnya = N */
    
    List ll, lr;
    
    if (N == 1) {
        // Basis-1: level 1 adalah akar current
        return Konso(Akar(P), Nil);
    } else {
        // Rekurens: cari di level N-1 pada subpohon
        if (IsUnerLeft(P))
            return MakeListLevelRecc(Left(P), N - 1);
        else if (IsUnerRight(P))
            return MakeListLevelRecc(Right(P), N - 1);
        else { // IsBiner(P)
            ll = MakeListLevelRecc(Left(P), N - 1);
            lr = MakeListLevelRecc(Right(P), N - 1);
            
            if (ll != Nil && lr != Nil)
                return Concat(ll, lr);
            else
                return Nil;
        }
    }
}
```

**Logika:**
- Kurangi N setiap turun satu level
- Ketika N = 1, ambil node current
- Gabungkan hasil dari subpohon kiri dan kanan

**Contoh:**
```
Tree:       5  (level 1)
           / \
          3   8  (level 2)
         / \
        1   4  (level 3)

MakeListLevel(P, 1) → [5]
MakeListLevel(P, 2) → [3, 8]
MakeListLevel(P, 3) → [1, 4]
```

---

## Contoh Program Lengkap

```cpp
#include <iostream>
using namespace std;

typedef int infotype;
typedef struct tNode *addrNode;
typedef addrNode BinTree;

typedef struct tNode {
    infotype info;
    addrNode left;
    addrNode right;
} Node;

#define Akar(P) (P)->info
#define Left(P) (P)->left
#define Right(P) (P)->right
#define Nil NULL

// Fungsi dari Tree Bagian 1
bool IsTreeEmpty(BinTree P) {
    return (P == Nil);
}

bool IsTreeOneElmt(BinTree P) {
    if (P != Nil)
        return (Left(P) == Nil && Right(P) == Nil);
    else
        return false;
}

bool IsUnerLeft(BinTree P) {
    if (P != Nil)
        return (Left(P) != Nil && Right(P) == Nil);
    else
        return false;
}

bool IsUnerRight(BinTree P) {
    if (P != Nil)
        return (Left(P) == Nil && Right(P) != Nil);
    else
        return false;
}

bool IsBiner(BinTree P) {
    if (P != Nil)
        return (Left(P) != Nil && Right(P) != Nil);
    else
        return false;
}

addrNode AlokNode(infotype X) {
    addrNode P = (addrNode)malloc(sizeof(Node));
    if (P != Nil) {
        Akar(P) = X;
        Left(P) = Nil;
        Right(P) = Nil;
    }
    return P;
}

BinTree Tree(infotype A, BinTree L, BinTree R) {
    BinTree T = AlokNode(A);
    if (T != Nil) {
        Left(T) = L;
        Right(T) = R;
    }
    return T;
}

// Fungsi SearchTree
bool SearchTree(BinTree P, infotype X) {
    if (IsTreeEmpty(P))
        return false;
    else {
        if (Akar(P) == X)
            return true;
        else
            return (SearchTree(Left(P), X) || SearchTree(Right(P), X));
    }
}

// Fungsi SearchDaun
bool SearchDaun(BinTree P, infotype X) {
    if (IsTreeOneElmt(P))
        return (Akar(P) == X);
    else {
        if (IsUnerLeft(P))
            return SearchDaun(Left(P), X);
        else if (IsUnerRight(P))
            return SearchDaun(Right(P), X);
        else // IsBiner(P)
            return (SearchDaun(Left(P), X) || SearchDaun(Right(P), X));
    }
}

// Fungsi IsSkewLeft
bool IsSkewLeft(BinTree P) {
    if (IsTreeEmpty(P))
        return true;
    else if (IsTreeOneElmt(P))
        return true;
    else {
        if (IsUnerLeft(P))
            return IsSkewLeft(Left(P));
        else
            return false;
    }
}

// Fungsi IsSkewRight
bool IsSkewRight(BinTree P) {
    if (IsTreeEmpty(P))
        return true;
    else if (IsTreeOneElmt(P))
        return true;
    else {
        if (IsUnerRight(P))
            return IsSkewRight(Right(P));
        else
            return false;
    }
}

// Fungsi Level
int Level(BinTree P, infotype X) {
    if (Akar(P) == X)
        return 1;
    else {
        if (SearchTree(Left(P), X))
            return (1 + Level(Left(P), X));
        else
            return (1 + Level(Right(P), X));
    }
}

int main() {
    // Membuat tree:
    //       5
    //      / \
    //     3   8
    //    / \
    //   1   4
    
    BinTree leaf1 = Tree(1, Nil, Nil);
    BinTree leaf4 = Tree(4, Nil, Nil);
    BinTree leaf8 = Tree(8, Nil, Nil);
    BinTree node3 = Tree(3, leaf1, leaf4);
    BinTree root = Tree(5, node3, leaf8);
    
    // Test SearchTree
    cout << "=== TEST SEARCHTREE ===" << endl;
    cout << "SearchTree(P, 5): " << (SearchTree(root, 5) ? "true" : "false") << endl;
    cout << "SearchTree(P, 1): " << (SearchTree(root, 1) ? "true" : "false") << endl;
    cout << "SearchTree(P, 9): " << (SearchTree(root, 9) ? "true" : "false") << endl;
    
    // Test SearchDaun
    cout << "\n=== TEST SEARCHDAUN ===" << endl;
    cout << "SearchDaun(P, 5): " << (SearchDaun(root, 5) ? "true" : "false") << endl;
    cout << "SearchDaun(P, 1): " << (SearchDaun(root, 1) ? "true" : "false") << endl;
    cout << "SearchDaun(P, 8): " << (SearchDaun(root, 8) ? "true" : "false") << endl;
    
    // Test Level
    cout << "\n=== TEST LEVEL ===" << endl;
    cout << "Level(P, 5): " << Level(root, 5) << endl;
    cout << "Level(P, 3): " << Level(root, 3) << endl;
    cout << "Level(P, 1): " << Level(root, 1) << endl;
    cout << "Level(P, 4): " << Level(root, 4) << endl;
    
    // Test IsSkewLeft dan IsSkewRight
    cout << "\n=== TEST SKEW ===" << endl;
    cout << "IsSkewLeft(P): " << (IsSkewLeft(root) ? "true" : "false") << endl;
    cout << "IsSkewRight(P): " << (IsSkewRight(root) ? "true" : "false") << endl;
    
    // Membuat tree condong kiri
    BinTree skewC = Tree(3, Nil, Nil);
    BinTree skewB = Tree(2, skewC, Nil);
    BinTree skewA = Tree(1, skewB, Nil);
    
    cout << "\nTree condong kiri:" << endl;
    cout << "IsSkewLeft: " << (IsSkewLeft(skewA) ? "true" : "false") << endl;
    cout << "IsSkewRight: " << (IsSkewRight(skewA) ? "true" : "false") << endl;
    
    return 0;
}
```

**Output Program:**
```
=== TEST SEARCHTREE ===
SearchTree(P, 5): true
SearchTree(P, 1): true
SearchTree(P, 9): false

=== TEST SEARCHDAUN ===
SearchDaun(P, 5): false
SearchDaun(P, 1): true
SearchDaun(P, 8): true

=== TEST LEVEL ===
Level(P, 5): 1
Level(P, 3): 2
Level(P, 1): 3
Level(P, 4): 3

=== TEST SKEW ===
IsSkewLeft(P): false
IsSkewRight(P): false

Tree condong kiri:
IsSkewLeft: true
IsSkewRight: false
```

---

*Materi - Tree Bagian 2*

---
