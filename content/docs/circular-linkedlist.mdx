---
title: Circular Linked List
description: Memahami konsep Circular Linked List sebagai variasi struktur data linked list dengan koneksi sirkuler dalam pemrograman
---

**Circular Linked List** adalah variasi dari linked list dimana elemen terakhir terhubung kembali ke elemen pertama, membentuk struktur sirkuler tanpa ada pointer NULL.  
**Node** adalah unit dasar dalam circular linked list yang terdiri dari dua bagian: informasi data (info) dan pointer ke node selanjutnya (next).  
**Address/Pointer** adalah alamat memori yang menunjuk ke lokasi node dalam circular linked list.

Circular linked list sangat berguna untuk aplikasi yang memerlukan proses berulang terus-menerus, seperti penjadwalan CPU round robin, playlist musik yang berputar, dan game turn-based.

---

## Tujuan Pembelajaran

Setelah mempelajari materi ini, mahasiswa diharapkan mampu:

- **Memahami konsep Circular Linked List** sebagai variasi dari linked list dengan struktur sirkuler.
- **Mendeklarasikan dan menggunakan Circular Linked List** dengan sintaks yang benar sesuai aturan bahasa pemrograman C++.
- **Mengimplementasikan operasi dasar** seperti insertion, deletion, dan traversal pada Circular Linked List.
- **Menerapkan Circular Linked List dalam program** untuk menyelesaikan masalah yang memerlukan proses siklik berulang.

---

## Mengapa Penting?

1. **Tidak Ada End Point**  
   Tidak seperti linked list biasa yang berakhir dengan NULL, circular linked list memungkinkan navigasi tanpa batas, cocok untuk proses yang berulang terus-menerus.

2. **Efisiensi dalam Round Robin**  
   Sangat efisien untuk implementasi algoritma penjadwalan round robin dalam sistem operasi, dimana setiap proses mendapat giliran secara berulang.

3. **Akses Mudah ke Semua Elemen**  
   Dari node manapun, semua node lain dapat diakses tanpa perlu kembali ke awal list.

4. **Implementasi Struktur Siklik**  
   Cocok untuk merepresentasikan struktur data yang secara alami bersifat siklik seperti jam, hari dalam seminggu, atau playlist musik.

---

## Masalah dengan Linear Linked List

Bayangkan membuat sistem playlist musik yang harus berputar terus:

```cpp
// Linear Linked List - tidak efisien untuk loop
struct Song {
    string title;
    Song* next;
};

void playAllSongs(Song* first) {
    Song* current = first;
    while (current != NULL) {
        playSong(current->title);
        current = current->next;
    }
    // Harus kembali ke awal secara manual
    current = first;  // Reset ke awal
}
```

**Masalah:**
- Harus reset manual ke awal setelah mencapai akhir
- Tidak ada kontinuitas natural dalam looping
- Perlu logic tambahan untuk implementasi round robin

---

## Konsep Circular Linked List

### Definisi dan Karakteristik

Circular Linked List memiliki karakteristik utama:
- **Sirkuler**: Elemen terakhir menunjuk kembali ke elemen pertama
- **Tidak Ada NULL**: Tidak ada pointer yang bernilai NULL (kecuali list kosong)
- **Kontinuous Access**: Dapat terus melakukan traversal tanpa batas
- **First Pointer**: Menunjuk ke node yang dianggap sebagai "awal" list

### Visualisasi Circular Linked List

#### Struktur Node Individual
```
┌──────┬─────┐
│ Data │Next │  ← Setiap node memiliki 2 komponen
└──────┴─────┘
   ↑      ↑
   │      └── Pointer ke node selanjutnya (tidak pernah NULL)
   └─────── Data/informasi yang disimpan  
```

#### Visualisasi Sederhana dengan Panah
```
First → [10] → [20] → [30] → [40] ──┐
         ↑                          │
         └──────────────────────────┘

Keterangan:
→ : Pointer next
[n]: Node dengan data n  
┌─┘: Koneksi kembali ke First (membentuk circle)
```

#### Traversal dalam Loop
```
Mulai dari First: [10] → [20] → [30] → [40] → [10] → [20] → ...
                   ↑                          ↑
                 Start                   Kembali ke awal
```

---

## Struktur Node dan Definisi

### Definisi Struktur Node
```cpp
typedef int infotype;
typedef struct tElmtList *address;

typedef struct tElmtList {
    infotype info;  // Data yang disimpan
    address next;   // Pointer ke node selanjutnya
} ElmtList;

typedef struct {
    address First;  // Pointer ke node yang dianggap pertama
} List;
```

### Konsep Dasar
- **First(L)**: Alamat elemen yang dianggap pertama dalam list L
- **Info(P)**: Nilai/data yang disimpan pada node yang ditunjuk P
- **Next(P)**: Alamat elemen selanjutnya dari node yang ditunjuk P
- **List Kosong**: First(L) = NULL
- **Elemen Terakhir**: Next(Last) = First(L) (menunjuk kembali ke first)
- **Tidak Ada NULL**: Semua Next pointer menunjuk ke node valid (kecuali list kosong)

---

## Operasi Dasar Circular Linked List

### 1. Inisialisasi List Kosong
```cpp
void CreateEmpty(List *L) {
    (*L).First = NULL;
}
```

### 2. Mengecek List Kosong
```cpp
bool IsEmpty(List L) {
    return L.First == NULL;
}
```

### 3. Alokasi Node Baru
```cpp
address Allocation(infotype x) {
    address NewElmt;
    
    NewElmt = new ElmtList;
    if (NewElmt != NULL) {
        NewElmt->info = x;
        NewElmt->next = NULL;
    }
    
    return NewElmt;
}
```

### 4. Dealokasi Node
```cpp
void Deallocation(address hapus) {
    delete hapus;
}
```

---

## Operasi Insertion (Penambahan Data)

### Insert di Awal (InsertFirst)
```cpp
void InsertFirst(List *L, infotype x) {
    address NewElmt = Allocation(x);
    
    if (NewElmt != NULL) {
        if (IsEmpty(*L)) {
            // List kosong - node menunjuk ke dirinya sendiri
            NewElmt->next = NewElmt;
            (*L).First = NewElmt;
        } else {
            // Cari node terakhir (yang menunjuk ke First)
            address temp = (*L).First;
            while (temp->next != (*L).First) {
                temp = temp->next;
            }
            
            // Insert di awal
            NewElmt->next = (*L).First;
            temp->next = NewElmt;  // Last node menunjuk ke NewElmt
            (*L).First = NewElmt;
        }
    }
}
```

### Insert Setelah Node Tertentu (InsertAfter)
```cpp
void InsertAfter(address PredElmt, infotype x) {
    if (PredElmt != NULL) {
        address NewElmt = Allocation(x);
        
        if (NewElmt != NULL) {
            NewElmt->next = PredElmt->next;
            PredElmt->next = NewElmt;
        }
    }
}
```

### Insert di Akhir (InsertLast)
```cpp
void InsertLast(List *L, infotype x) {
    if (IsEmpty(*L)) {
        InsertFirst(L, x);
    } else {
        address NewElmt = Allocation(x);
        
        if (NewElmt != NULL) {
            // Cari node terakhir
            address temp = (*L).First;
            while (temp->next != (*L).First) {
                temp = temp->next;
            }
            
            // Insert di akhir
            NewElmt->next = (*L).First;  // NewElmt menunjuk ke First
            temp->next = NewElmt;        // Last node menunjuk ke NewElmt
        }
    }
}
```

---

## Operasi Deletion (Penghapusan Data)

### Delete di Awal (DeleteFirst)
```cpp
void DeleteFirst(List *L, infotype *hapus) {
    if (!IsEmpty(*L)) {
        address temp = (*L).First;
        *hapus = temp->info;
        
        if (temp->next == temp) {
            // Hanya satu elemen
            (*L).First = NULL;
        } else {
            // Cari node terakhir
            address last = (*L).First;
            while (last->next != (*L).First) {
                last = last->next;
            }
            
            // Update pointer
            (*L).First = temp->next;
            last->next = (*L).First;
        }
        
        temp->next = NULL;
        Deallocation(temp);
    }
}
```

### Delete Setelah Node Tertentu (DeleteAfter)
```cpp
void DeleteAfter(List *L, address PredElmt, infotype *hapus) {
    if (PredElmt != NULL && PredElmt->next != NULL) {
        address temp = PredElmt->next;
        *hapus = temp->info;
        
        if (temp == (*L).First && temp->next == temp) {
            // Hapus satu-satunya elemen
            (*L).First = NULL;
        } else {
            PredElmt->next = temp->next;
            
            // Jika yang dihapus adalah First
            if (temp == (*L).First) {
                (*L).First = temp->next;
            }
        }
        
        temp->next = NULL;
        Deallocation(temp);
    }
}
```

### Delete di Akhir (DeleteLast)
```cpp
void DeleteLast(List *L, infotype *hapus) {
    if (!IsEmpty(*L)) {
        address temp = (*L).First;
        
        if (temp->next == temp) {
            // Hanya satu elemen
            *hapus = temp->info;
            (*L).First = NULL;
            Deallocation(temp);
        } else {
            // Cari node sebelum terakhir
            address predLast = (*L).First;
            while (predLast->next->next != (*L).First) {
                predLast = predLast->next;
            }
            
            address last = predLast->next;
            *hapus = last->info;
            predLast->next = (*L).First;
            
            last->next = NULL;
            Deallocation(last);
        }
    }
}
```

---

## Traversal (Pembacaan Data)

### Menampilkan Semua Elemen
```cpp
void PrintList(List L) {
    if (!IsEmpty(L)) {
        address temp = L.First;
        
        cout << "Isi List (Circular): ";
        do {
            cout << temp->info << " ";
            temp = temp->next;
        } while (temp != L.First);
        cout << " (kembali ke awal)" << endl;
    } else {
        cout << "List kosong" << endl;
    }
}
```

### Traversal dengan Batas Iterasi
```cpp
void PrintListNTimes(List L, int n) {
    if (!IsEmpty(L)) {
        address temp = L.First;
        int count = 0;
        
        cout << "Isi List (" << n << " iterasi): ";
        do {
            cout << temp->info << " ";
            temp = temp->next;
            count++;
        } while (count < n);
        cout << endl;
    }
}
```

---

## Contoh Program Lengkap

```cpp
#include <iostream>
using namespace std;

// Definisi struktur dan fungsi-fungsi di atas...

int main() {
    List data;
    CreateEmpty(&data);
    
    int pilihan, nilai, hapus, n;
    
    do {
        cout << "\n=== MENU CIRCULAR LINKED LIST ===" << endl;
        cout << "1. Insert First" << endl;
        cout << "2. Insert Last" << endl;
        cout << "3. Delete First" << endl;
        cout << "4. Delete Last" << endl;
        cout << "5. Print List" << endl;
        cout << "6. Print N Times (Demo Circular)" << endl;
        cout << "7. Check Empty" << endl;
        cout << "0. Exit" << endl;
        cout << "Pilihan: ";
        cin >> pilihan;
        
        switch(pilihan) {
            case 1:
                cout << "Masukkan nilai: ";
                cin >> nilai;
                InsertFirst(&data, nilai);
                cout << "Data berhasil ditambahkan di awal" << endl;
                break;
            case 2:
                cout << "Masukkan nilai: ";
                cin >> nilai;
                InsertLast(&data, nilai);
                cout << "Data berhasil ditambahkan di akhir" << endl;
                break;
            case 3:
                if (!IsEmpty(data)) {
                    DeleteFirst(&data, &hapus);
                    cout << "Data terhapus: " << hapus << endl;
                } else {
                    cout << "List kosong!" << endl;
                }
                break;
            case 4:
                if (!IsEmpty(data)) {
                    DeleteLast(&data, &hapus);
                    cout << "Data terhapus: " << hapus << endl;
                } else {
                    cout << "List kosong!" << endl;
                }
                break;
            case 5:
                PrintList(data);
                break;
            case 6:
                cout << "Berapa kali iterasi? ";
                cin >> n;
                PrintListNTimes(data, n);
                break;
            case 7:
                if (IsEmpty(data)) {
                    cout << "List kosong" << endl;
                } else {
                    cout << "List tidak kosong" << endl;
                }
                break;
        }
    } while(pilihan != 0);
    
    return 0;
}
```

---

## Algoritma Pencarian dalam Circular Linked List

### Pencarian dengan Batas
```cpp
address Search(List L, infotype x) {
    if (!IsEmpty(L)) {
        address temp = L.First;
        
        do {
            if (temp->info == x) {
                return temp;
            }
            temp = temp->next;
        } while (temp != L.First);
    }
    
    return NULL;  // Tidak ditemukan
}
```

### Menghitung Jumlah Elemen
```cpp
int CountElements(List L) {
    if (IsEmpty(L)) {
        return 0;
    }
    
    int count = 0;
    address temp = L.First;
    
    do {
        count++;
        temp = temp->next;
    } while (temp != L.First);
    
    return count;
}
```
---

*Materi - Circular Linked List*